From 3cc7903b8fd18291edadd9cfc7f5d01c2719e2c3 Mon Sep 17 00:00:00 2001
From: Kartatz <105828205+Kartatz@users.noreply.github.com>
Date: Thu, 9 Oct 2025 19:32:30 -0300
Subject: [PATCH] Revert "vect: Remove type from misalignment hook."

This reverts commit 5e9eecc66867ba0ae7df20f1cd526ad38fd1888f.
---
 gcc/config/aarch64/aarch64.cc     |  5 +++--
 gcc/config/arm/arm.cc             |  5 +++--
 gcc/config/epiphany/epiphany.cc   |  6 +++---
 gcc/config/gcn/gcn.cc             |  3 ++-
 gcc/config/loongarch/loongarch.cc |  3 ++-
 gcc/config/riscv/riscv.cc         | 11 ++++++-----
 gcc/config/rs6000/rs6000.cc       | 13 +++++++------
 gcc/config/s390/s390.cc           |  3 ++-
 gcc/doc/tm.texi                   | 12 ++++++------
 gcc/target.def                    | 12 ++++++------
 gcc/targhooks.cc                  |  2 ++
 gcc/targhooks.h                   |  1 +
 gcc/tree-vect-data-refs.cc        | 15 ++++++---------
 13 files changed, 49 insertions(+), 42 deletions(-)

diff --git a/gcc/config/aarch64/aarch64.cc b/gcc/config/aarch64/aarch64.cc
index 9d2c3431a..031da8638 100644
--- a/gcc/config/aarch64/aarch64.cc
+++ b/gcc/config/aarch64/aarch64.cc
@@ -355,6 +355,7 @@ static void aarch64_override_options_after_change (void);
 static bool aarch64_vector_mode_supported_p (machine_mode);
 static int aarch64_address_cost (rtx, machine_mode, addr_space_t, bool);
 static bool aarch64_builtin_support_vector_misalignment (machine_mode mode,
+							 const_tree type,
 							 int misalignment,
 							 bool is_packed,
 							 bool is_gather_scatter);
@@ -24563,7 +24564,7 @@ aarch64_simd_vector_alignment_reachable (const_tree type, bool is_packed)
    target.  */
 static bool
 aarch64_builtin_support_vector_misalignment (machine_mode mode,
-					     int misalignment,
+					     const_tree type, int misalignment,
 					     bool is_packed,
 					     bool is_gather_scatter)
 {
@@ -24580,7 +24581,7 @@ aarch64_builtin_support_vector_misalignment (machine_mode mode,
       if (misalignment == -1)
 	return false;
     }
-  return default_builtin_support_vector_misalignment (mode, misalignment,
+  return default_builtin_support_vector_misalignment (mode, type, misalignment,
 						      is_packed,
 						      is_gather_scatter);
 }
diff --git a/gcc/config/arm/arm.cc b/gcc/config/arm/arm.cc
index f074a4292..8b951f3d4 100644
--- a/gcc/config/arm/arm.cc
+++ b/gcc/config/arm/arm.cc
@@ -287,6 +287,7 @@ static bool arm_class_likely_spilled_p (reg_class_t);
 static HOST_WIDE_INT arm_vector_alignment (const_tree type);
 static bool arm_vector_alignment_reachable (const_tree type, bool is_packed);
 static bool arm_builtin_support_vector_misalignment (machine_mode mode,
+						     const_tree type,
 						     int misalignment,
 						     bool is_packed,
 						     bool is_gather_scatter);
@@ -30661,7 +30662,7 @@ arm_vector_alignment_reachable (const_tree type, bool is_packed)
 
 static bool
 arm_builtin_support_vector_misalignment (machine_mode mode,
-					 int misalignment,
+					 const_tree type, int misalignment,
 					 bool is_packed,
 					 bool is_gather_scatter)
 {
@@ -30687,7 +30688,7 @@ arm_builtin_support_vector_misalignment (machine_mode mode,
       return ((misalignment % align) == 0);
     }
 
-  return default_builtin_support_vector_misalignment (mode, misalignment,
+  return default_builtin_support_vector_misalignment (mode, type, misalignment,
 						      is_packed,
 						      is_gather_scatter);
 }
diff --git a/gcc/config/epiphany/epiphany.cc b/gcc/config/epiphany/epiphany.cc
index 2446b0238..f53a64357 100644
--- a/gcc/config/epiphany/epiphany.cc
+++ b/gcc/config/epiphany/epiphany.cc
@@ -2815,15 +2815,15 @@ epiphany_vector_alignment_reachable (const_tree type, bool is_packed)
 }
 
 static bool
-epiphany_support_vector_misalignment (machine_mode mode, int misalignment,
-				      bool is_packed,
+epiphany_support_vector_misalignment (machine_mode mode, const_tree type,
+				      int misalignment, bool is_packed,
 				      bool is_gather_scatter)
 {
   if (is_gather_scatter)
     return true;
   if (GET_MODE_SIZE (mode) == 8 && misalignment % 4 == 0)
     return true;
-  return default_builtin_support_vector_misalignment (mode, misalignment,
+  return default_builtin_support_vector_misalignment (mode, type, misalignment,
 						      is_packed,
 						      is_gather_scatter);
 }
diff --git a/gcc/config/gcn/gcn.cc b/gcc/config/gcn/gcn.cc
index 1e04074d7..f3b6efc40 100644
--- a/gcc/config/gcn/gcn.cc
+++ b/gcc/config/gcn/gcn.cc
@@ -5368,13 +5368,14 @@ gcn_preferred_vector_alignment (const_tree type)
 
 static bool
 gcn_vectorize_support_vector_misalignment (machine_mode ARG_UNUSED (mode),
+					   const_tree ARG_UNUSED (type),
 					   int ARG_UNUSED (misalignment),
 					   bool is_packed,
 					   bool ARG_UNUSED (is_gather_scatter))
 {
   /* All Flat and Global load instructions support arbitrary alignment, so
      the types and such are irrelevant (Buffer instructions are not used).  */
-
+ 
   /* Disallow packed accesses because expand attempts to take scalar subregs of
      vector registers, which is nonsense.
      Testcase: gfortran.dg/recursive_alloc_comp_4.f08   */
diff --git a/gcc/config/loongarch/loongarch.cc b/gcc/config/loongarch/loongarch.cc
index 3fe8c766c..4d82fc8b6 100644
--- a/gcc/config/loongarch/loongarch.cc
+++ b/gcc/config/loongarch/loongarch.cc
@@ -11058,6 +11058,7 @@ void loongarch_emit_swdivsf (rtx res, rtx a, rtx b, machine_mode mode)
 
 static bool
 loongarch_builtin_support_vector_misalignment (machine_mode mode,
+					       const_tree type,
 					       int misalignment,
 					       bool is_packed,
 					       bool is_gather_scatter)
@@ -11071,7 +11072,7 @@ loongarch_builtin_support_vector_misalignment (machine_mode mode,
       if (misalignment == -1)
 	return false;
     }
-  return default_builtin_support_vector_misalignment (mode, misalignment,
+  return default_builtin_support_vector_misalignment (mode, type, misalignment,
 						      is_packed,
 						      is_gather_scatter);
 }
diff --git a/gcc/config/riscv/riscv.cc b/gcc/config/riscv/riscv.cc
index a30c9f1dd..c81a2e4b4 100644
--- a/gcc/config/riscv/riscv.cc
+++ b/gcc/config/riscv/riscv.cc
@@ -12659,11 +12659,12 @@ riscv_estimated_poly_value (poly_int64 val,
 /* Return true if the vector misalignment factor is supported by the
    target.  */
 bool
-riscv_support_vector_misalignment (machine_mode mode, int misalignment,
-				   bool is_packed, bool is_gather_scatter)
+riscv_support_vector_misalignment (machine_mode mode, const_tree type,
+				   int misalignment, bool is_packed,
+				   bool is_gather_scatter)
 {
   /* IS_PACKED is true if the corresponding scalar element is not naturally
-     aligned.  If the misalignment is unknown and the access is packed
+     aligned.  If the misalignment is unknown and the the access is packed
      we defer to the default hook which will check if movmisalign is present.
      Movmisalign, in turn, depends on TARGET_VECTOR_MISALIGN_SUPPORTED.  */
   if (misalignment == DR_MISALIGNMENT_UNKNOWN)
@@ -12675,12 +12676,12 @@ riscv_support_vector_misalignment (machine_mode mode, int misalignment,
     {
       /* If we know that misalignment is a multiple of the element size, we're
 	 good.  */
-      if (misalignment % (GET_MODE_UNIT_SIZE (mode)) == 0)
+      if (misalignment % TYPE_ALIGN_UNIT (type) == 0)
 	return true;
     }
 
   /* Otherwise fall back to movmisalign again.  */
-  return default_builtin_support_vector_misalignment (mode, misalignment,
+  return default_builtin_support_vector_misalignment (mode, type, misalignment,
 						      is_packed,
 						      is_gather_scatter);
 }
diff --git a/gcc/config/rs6000/rs6000.cc b/gcc/config/rs6000/rs6000.cc
index 1d5cd25c0..1049c446c 100644
--- a/gcc/config/rs6000/rs6000.cc
+++ b/gcc/config/rs6000/rs6000.cc
@@ -4947,6 +4947,7 @@ rs6000_vector_alignment_reachable (const_tree type ATTRIBUTE_UNUSED, bool is_pac
    target.  */
 static bool
 rs6000_builtin_support_vector_misalignment (machine_mode mode,
+					    const_tree type,
 					    int misalignment,
 					    bool is_packed,
 					    bool is_gather_scatter)
@@ -4972,13 +4973,13 @@ rs6000_builtin_support_vector_misalignment (machine_mode mode,
 	{
 	  /* Misalignment factor is unknown at compile time but we know
 	     it's word aligned.  */
-	  if (rs6000_vector_alignment_reachable (NULL_TREE, is_packed))
-	    {
-	      int element_size = GET_MODE_UNIT_BITSIZE (mode);
+	  if (rs6000_vector_alignment_reachable (type, is_packed))
+            {
+              int element_size = TREE_INT_CST_LOW (TYPE_SIZE (type));
 
-	      if (element_size == 64 || element_size == 32)
-		return true;
-	    }
+              if (element_size == 64 || element_size == 32)
+               return true;
+            }
 
 	  return false;
 	}
diff --git a/gcc/config/s390/s390.cc b/gcc/config/s390/s390.cc
index d65109026..1a47f477d 100644
--- a/gcc/config/s390/s390.cc
+++ b/gcc/config/s390/s390.cc
@@ -17503,6 +17503,7 @@ s390_preferred_simd_mode (scalar_mode mode)
 /* Our hardware does not require vectors to be strictly aligned.  */
 static bool
 s390_support_vector_misalignment (machine_mode mode ATTRIBUTE_UNUSED,
+				  const_tree type ATTRIBUTE_UNUSED,
 				  int misalignment ATTRIBUTE_UNUSED,
 				  bool is_packed ATTRIBUTE_UNUSED,
 				  bool is_gather_scatter ATTRIBUTE_UNUSED)
@@ -17510,7 +17511,7 @@ s390_support_vector_misalignment (machine_mode mode ATTRIBUTE_UNUSED,
   if (TARGET_VX)
     return true;
 
-  return default_builtin_support_vector_misalignment (mode, misalignment,
+  return default_builtin_support_vector_misalignment (mode, type, misalignment,
 						      is_packed,
 						      is_gather_scatter);
 }
diff --git a/gcc/doc/tm.texi b/gcc/doc/tm.texi
index 930003725..989e01fbd 100644
--- a/gcc/doc/tm.texi
+++ b/gcc/doc/tm.texi
@@ -6397,14 +6397,14 @@ return type of the vectorized function shall be of vector type
 @var{vec_type_out} and the argument types should be @var{vec_type_in}.
 @end deftypefn
 
-@deftypefn {Target Hook} bool TARGET_VECTORIZE_SUPPORT_VECTOR_MISALIGNMENT (machine_mode @var{mode}, int @var{misalignment}, bool @var{is_packed}, bool @var{is_gather_scatter})
+@deftypefn {Target Hook} bool TARGET_VECTORIZE_SUPPORT_VECTOR_MISALIGNMENT (machine_mode @var{mode}, const_tree @var{type}, int @var{misalignment}, bool @var{is_packed}, bool @var{is_gather_scatter})
 This hook should return true if the target supports misaligned vector
 store/load of a specific factor denoted in the @var{misalignment}
-parameter.  The vector store/load should be of machine mode @var{mode}.
-The @var{is_packed} parameter is true if the original memory access is
-not naturally aligned.  @var{is_gather_scatter} is true if the
-load/store is a gather or scatter.  In that case misalignment
-denotes the misalignment of @var{mode}'s element mode.
+parameter.  The vector store/load should be of machine mode @var{mode} and
+the elements in the vectors should be of type @var{type}.  The
+@var{is_packed} parameter is true if the misalignment is unknown and the
+memory access is defined in a packed struct.  @var{is_gather_scatter} is true
+if the load/store is a gather or scatter.
 @end deftypefn
 
 @deftypefn {Target Hook} machine_mode TARGET_VECTORIZE_PREFERRED_SIMD_MODE (scalar_mode @var{mode})
diff --git a/gcc/target.def b/gcc/target.def
index 31c7af1f8..3e58dcf54 100644
--- a/gcc/target.def
+++ b/gcc/target.def
@@ -1925,13 +1925,13 @@ DEFHOOK
 (support_vector_misalignment,
  "This hook should return true if the target supports misaligned vector\n\
 store/load of a specific factor denoted in the @var{misalignment}\n\
-parameter.  The vector store/load should be of machine mode @var{mode}.\n\
-The @var{is_packed} parameter is true if the original memory access is\n\
-not naturally aligned.  @var{is_gather_scatter} is true if the\n\
-load/store is a gather or scatter.  In that case misalignment\n\
-denotes the misalignment of @var{mode}'s element mode.",
+parameter.  The vector store/load should be of machine mode @var{mode} and\n\
+the elements in the vectors should be of type @var{type}.  The\n\
+@var{is_packed} parameter is true if the misalignment is unknown and the\n\
+memory access is defined in a packed struct.  @var{is_gather_scatter} is true\n\
+if the load/store is a gather or scatter.",
  bool,
- (machine_mode mode, int misalignment, bool is_packed,
+ (machine_mode mode, const_tree type, int misalignment, bool is_packed,
   bool is_gather_scatter),
  default_builtin_support_vector_misalignment)
 
diff --git a/gcc/targhooks.cc b/gcc/targhooks.cc
index 42c11681b..7ae048ca1 100644
--- a/gcc/targhooks.cc
+++ b/gcc/targhooks.cc
@@ -1559,6 +1559,8 @@ default_builtin_vector_alignment_reachable (const_tree /*type*/, bool is_packed)
    is_packed is true if the memory access is defined in a packed struct.  */
 bool
 default_builtin_support_vector_misalignment (machine_mode mode,
+					     const_tree type
+					     ATTRIBUTE_UNUSED,
 					     int misalignment
 					     ATTRIBUTE_UNUSED,
 					     bool is_packed
diff --git a/gcc/targhooks.h b/gcc/targhooks.h
index 441206763..34c30d4af 100644
--- a/gcc/targhooks.h
+++ b/gcc/targhooks.h
@@ -113,6 +113,7 @@ extern poly_uint64 default_preferred_vector_alignment (const_tree);
 extern bool default_builtin_vector_alignment_reachable (const_tree, bool);
 extern bool
 default_builtin_support_vector_misalignment (machine_mode mode,
+					     const_tree,
 					     int, bool, bool);
 extern machine_mode default_preferred_simd_mode (scalar_mode mode);
 extern machine_mode default_split_reduction (machine_mode);
diff --git a/gcc/tree-vect-data-refs.cc b/gcc/tree-vect-data-refs.cc
index c79411088..c40a52059 100644
--- a/gcc/tree-vect-data-refs.cc
+++ b/gcc/tree-vect-data-refs.cc
@@ -6522,8 +6522,7 @@ vect_can_force_dr_alignment_p (const_tree decl, poly_uint64 alignment)
    alignment.
    If CHECK_ALIGNED_ACCESSES is TRUE, check if the access is supported even
    it is aligned, i.e., check if it is possible to vectorize it with different
-   alignment.  If IS_GATHER_SCATTER is true we are dealing with a
-   gather/scatter.  */
+   alignment.  If GS_INFO is passed we are dealing with a gather/scatter.  */
 
 enum dr_alignment_support
 vect_supportable_dr_alignment (vec_info *vinfo, dr_vec_info *dr_info,
@@ -6637,13 +6636,11 @@ vect_supportable_dr_alignment (vec_info *vinfo, dr_vec_info *dr_info,
 	}
     }
 
-  bool is_packed = not_size_aligned (DR_REF (dr));
-  if (misalignment == DR_MISALIGNMENT_UNKNOWN
-      && is_gather_scatter)
-    misalignment = (get_object_alignment (DR_REF (dr))
-		    % (GET_MODE_BITSIZE (GET_MODE_INNER (mode))))
-      / BITS_PER_UNIT;
-  if (targetm.vectorize.support_vector_misalignment (mode, misalignment,
+  bool is_packed = false;
+  tree type = TREE_TYPE (DR_REF (dr));
+  if (misalignment == DR_MISALIGNMENT_UNKNOWN)
+    is_packed = not_size_aligned (DR_REF (dr));
+  if (targetm.vectorize.support_vector_misalignment (mode, type, misalignment,
 						     is_packed,
 						     is_gather_scatter))
     return dr_unaligned_supported;
-- 
2.50.1

